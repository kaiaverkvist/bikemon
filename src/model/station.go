package model

import "encoding/json"

// These Go structs were generated by pasting the response into:
// https://mholt.github.io/json-to-go/
// These two structs should then be joined to produce the result shown on the page.

type RequestResponse struct {
	LastUpdated int `json:"last_updated"`
	TTL         int `json:"ttl"`
	Data        struct {
		Stations []CompositeStation
	} `json:"data"`
}

type CompositeResponseData struct {
	LastUpdated int `json:"last_updated"`
	TTL         int `json:"ttl"`
	Data        struct {
		Stations []Station
	}
}

// Sub struct used for individual bike share stations.
type Station struct {
	StationID string `json:"station_id"`

	Name     string  `json:"name"`
	Address  string  `json:"address"`
	Lat      float64 `json:"lat"`
	Lon      float64 `json:"lon"`
	Capacity int     `json:"capacity"`

	IsInstalled       int `json:"is_installed"`
	IsRenting         int `json:"is_renting"`
	IsReturning       int `json:"is_returning"`
	LastReported      int `json:"last_reported"`
	NumBikesAvailable int `json:"num_bikes_available"`
	NumDocksAvailable int `json:"num_docks_available"`
}

// UnmarshalIntoCompositeStationData takes a raw JSON and converts it into the StationResponse model.
func UnmarshalIntoCompositeStationData(rawStationInformation string, rawStationStatus string) (error, *CompositeResponseData) {
	var response CompositeResponseData

	err := json.Unmarshal([]byte(rawStationInformation), &response)
	err = json.Unmarshal([]byte(rawStationStatus), &response)

	// Handle unmarshaling errors
	if err != nil {
		return err, nil
	}

	// No error, so response is ok.
	return nil, &response
}

// CreateCompositeStruct joins the two responses into a single object that has filtered IDs correctly.
// This is necessary because the responses are seperate initially, and we want to save time when processing the struct.
// If any optimizations have to be made later, this is probably one area where the request will bottleneck under load.
func (cr *CompositeResponseData) CreateCompositeStruct(status RequestResponse, station RequestResponse) *CompositeResponseData {
	var compositeResponse CompositeResponseData

	// We can use the first response's content.
	compositeResponse.LastUpdated = station.LastUpdated
	compositeResponse.TTL = station.TTL

	for _, srStation := range station.Data.Stations {
		for _, ssStation := range status.Data.Stations {
			if ssStation.StationID == srStation.StationID {

				var compositeStation Station

				// Results from srStation (StationResponse)
				compositeStation.StationID = srStation.StationID
				compositeStation.Name = srStation.Name
				compositeStation.Address = srStation.Address
				compositeStation.Lat = srStation.Lat
				compositeStation.Lon = srStation.Lon
				compositeStation.Capacity = srStation.Capacity

				// Results from ssStation (StationStatusResponse)
				compositeStation.IsInstalled = ssStation.IsInstalled
				compositeStation.IsRenting = ssStation.IsRenting
				compositeStation.IsReturning = ssStation.IsReturning
				compositeStation.LastReported = ssStation.LastReported
				compositeStation.NumBikesAvailable = ssStation.NumBikesAvailable
				compositeStation.NumDocksAvailable = ssStation.NumDocksAvailable

				// Add the stations to the composite struct we created.
				compositeResponse.Data.Stations = append(compositeResponse.Data.Stations, compositeStation)
			}
		}
	}

	return &compositeResponse
}

// CompositeStation is the shared struct between the two response types, populated as we go.
type CompositeStation struct {
	StationID string `json:"station_id"`

	Name     string  `json:"name"`
	Address  string  `json:"address"`
	Lat      float64 `json:"lat"`
	Lon      float64 `json:"lon"`
	Capacity int     `json:"capacity"`

	IsInstalled       int `json:"is_installed"`
	IsRenting         int `json:"is_renting"`
	IsReturning       int `json:"is_returning"`
	LastReported      int `json:"last_reported"`
	NumBikesAvailable int `json:"num_bikes_available"`
	NumDocksAvailable int `json:"num_docks_available"`
}
